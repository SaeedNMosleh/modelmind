import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';
import { IPrompt, ITestCase } from '@/lib/database/types';
import { PromptFooConfig, TestExecutionOptions } from './types';
import pino from 'pino';

const logger = pino({ name: 'config-generator' });

export class PromptFooConfigGenerator {
  private tempDir: string;

  constructor() {
    this.tempDir = path.join(os.tmpdir(), 'modelmind-promptfoo');
  }

  async ensureTempDir(): Promise<void> {
    try {
      await fs.access(this.tempDir);
    } catch {
      await fs.mkdir(this.tempDir, { recursive: true });
    }
  }

  async generateConfig(
    prompt: IPrompt,
    testCases: ITestCase[],
    options: TestExecutionOptions = {}
  ): Promise<{ config: PromptFooConfig; configPath: string }> {
    const activeVersion = prompt.versions.find(v => v.version === prompt.primaryVersion);
    if (!activeVersion) {
      throw new Error('No primary version found for prompt');
    }

    const config: PromptFooConfig = {
      prompts: [{
        id: `${prompt.name}-${activeVersion.version}`,
        template: activeVersion.template
      }],
      providers: this.generateProviders(options),
      tests: this.generateTests(testCases),
      defaultTest: {
        vars: {},
        assert: [
          {
            type: 'contains',
            value: '@startuml'
          },
          {
            type: 'contains', 
            value: '@enduml'
          }
        ]
      },
      evaluateOptions: {
        maxConcurrency: options.maxConcurrency || 3,
        repeat: 1,
        delay: 1000
      }
    };

    await this.ensureTempDir();
    const configId = uuidv4();
    const configPath = path.join(this.tempDir, `config-${configId}.yaml`);
    
    const yamlContent = this.generateYaml(config);
    await fs.writeFile(configPath, yamlContent, 'utf8');

    logger.info({
      promptId: prompt._id,
      promptName: prompt.name,
      version: activeVersion.version,
      testCaseCount: testCases.length,
      configPath
    }, 'Generated PromptFoo config');

    return { config, configPath };
  }

  private generateProviders(options: TestExecutionOptions): PromptFooConfig['providers'] {
    const provider = options.provider || 'openai';
    const model = options.model || 'gpt-4';
    const temperature = options.temperature ?? 0.7;

    const providers: PromptFooConfig['providers'] = [];

    if (provider === 'openai') {
      providers.push({
        id: 'openai',
        config: {
          apiKey: '${OPENAI_API_KEY}',
          model,
          temperature,
          ...(options.maxTokens && { max_tokens: options.maxTokens })
        }
      });
    } else if (provider === 'anthropic') {
      providers.push({
        id: 'anthropic',
        config: {
          apiKey: '${ANTHROPIC_API_KEY}',
          model,
          temperature,
          ...(options.maxTokens && { max_tokens: options.maxTokens })
        }
      });
    }

    return providers;
  }

  private generateTests(testCases: ITestCase[]): PromptFooConfig['tests'] {
    if (testCases.length === 0) {
      return [{
        vars: {
          input: 'Create a simple class diagram'
        },
        assert: [
          {
            type: 'contains',
            value: '@startuml'
          },
          {
            type: 'contains',
            value: '@enduml'
          },
          {
            type: 'javascript',
            value: 'output.includes("class") || output.includes("interface")'
          }
        ],
        description: 'Default test case for PlantUML generation'
      }];
    }

    return testCases.map(testCase => ({
      vars: testCase.vars,
      assert: testCase.assert,
      ...(testCase.description && { description: testCase.description })
    }));
  }

  private generateYaml(config: PromptFooConfig): string {
    const yaml = `# PromptFoo Configuration
# Generated by ModelMind Runtime Testing System

prompts:
${config.prompts.map(p => `  - id: "${p.id}"
    template: |
${p.template.split('\n').map(line => `      ${line}`).join('\n')}`).join('\n')}

providers:
${config.providers.map(p => `  - id: ${p.id}
    config:
${Object.entries(p.config).map(([key, value]) => `      ${key}: ${typeof value === 'string' ? `"${value}"` : value}`).join('\n')}`).join('\n')}

tests:
${config.tests.map(test => `  - vars:
${Object.entries(test.vars || {}).map(([key, value]) => `      ${key}: "${value}"`).join('\n')}
    assert:
${test.assert.map(assertion => {
  let assertStr = `      - type: ${assertion.type}`;
  if (assertion.value !== undefined) assertStr += `\n        value: "${assertion.value}"`;
  if (assertion.threshold !== undefined) assertStr += `\n        threshold: ${assertion.threshold}`;
  if (assertion.provider) assertStr += `\n        provider: "${assertion.provider}"`;
  if (assertion.metric) assertStr += `\n        metric: "${assertion.metric}"`;
  if (assertion.rubric) assertStr += `\n        rubric: "${assertion.rubric}"`;
  return assertStr;
}).join('\n')}${test.description ? `\n    description: "${test.description}"` : ''}`).join('\n')}

${config.defaultTest ? `defaultTest:
  vars:
${Object.entries(config.defaultTest.vars || {}).map(([key, value]) => `    ${key}: "${value}"`).join('\n')}
  assert:
${config.defaultTest.assert?.map(assertion => {
  let assertStr = `    - type: ${assertion.type}`;
  if (assertion.value !== undefined) assertStr += `\n      value: "${assertion.value}"`;
  if (assertion.threshold !== undefined) assertStr += `\n      threshold: ${assertion.threshold}`;
  return assertStr;
}).join('\n') || ''}` : ''}

evaluateOptions:
  maxConcurrency: ${config.evaluateOptions?.maxConcurrency || 3}
  repeat: ${config.evaluateOptions?.repeat || 1}
  delay: ${config.evaluateOptions?.delay || 1000}
`;

    return yaml;
  }

  async cleanupConfig(configPath: string): Promise<void> {
    try {
      await fs.unlink(configPath);
      logger.debug({ configPath }, 'Cleaned up config file');
    } catch (error) {
      logger.warn({ error, configPath }, 'Failed to cleanup config file');
    }
  }

  async cleanupAllConfigs(): Promise<void> {
    try {
      const files = await fs.readdir(this.tempDir);
      const configFiles = files.filter(file => file.startsWith('config-') && file.endsWith('.yaml'));
      
      await Promise.all(
        configFiles.map(file => 
          fs.unlink(path.join(this.tempDir, file)).catch(err => 
            logger.warn({ error: err, file }, 'Failed to cleanup config file')
          )
        )
      );

      logger.info({ cleanedFiles: configFiles.length }, 'Cleaned up all config files');
    } catch (error) {
      logger.warn({ error }, 'Failed to cleanup config directory');
    }
  }
}

export const configGenerator = new PromptFooConfigGenerator();